desc: Виртуальная 8.1 Система с HRTF матрицей v4.9.3
//tags: car, surround, processing, enhancer, HRTF, matrix
//author: Vov01210
//created: 2025-02-17 19:38:08
//modified: 2025-02-18 01:45:36
//version: 1.9.3

// ГРУППА 1: ГРОМКОСТЬ КАНАЛОВ
slider1:-2<-80,0,0.1>Фронт Левый: Гейн (дБ)
slider2:-2<-80,0,0.1>Фронт Правый: Гейн (дБ)
slider3:-2<-80,0,0.1>Центр: Гейн (дБ)
slider4:-2<-80,0,0.1>Тыл Левый: Гейн (дБ)
slider5:-2<-80,0,0.1>Тыл Правый: Гейн (дБ)
slider6:-2<-80,0,0.1>Тыл Центр: Гейн (дБ)
slider7:-1.5<-80,0,0.1>Сабвуфер: Гейн (дБ)
slider60:-2<-80,0,0.1>Центр Левый: Гейн (дБ)
slider61:-2<-80,0,0.1>Центр Правый: Гейн (дБ)

// ГРУППА 2: БАС-БУСТ
slider8:1.2<0,3,0.1>Фронт Левый: Бас-буст
slider9:1.2<0,3,0.1>Фронт Правый: Бас-буст
slider10:1.0<0,3,0.1>Центр: Бас-буст
slider11:1.2<0,3,0.1>Тыл Левый: Бас-буст
slider12:1.2<0,3,0.1>Тыл Правый: Бас-буст
slider13:1.0<0,3,0.1>Тыл Центр: Бас-буст
slider14:1.5<0,3,0.1>Сабвуфер: Бас-буст
slider62:1.0<0,3,0.1>Центр Левый: Бас-буст
slider63:1.0<0,3,0.1>Центр Правый: Бас-буст

// ГРУППА 3: ФИЛЬТРЫ
slider15:0<0,1,1>Фронт Левый: LPF Вкл/Выкл
slider16:0<0,1,1>Фронт Правый: LPF Вкл/Выкл
slider17:0<0,1,1>Центр: LPF Вкл/Выкл
slider18:0<0,1,1>Тыл Левый: LPF Вкл/Выкл
slider19:0<0,1,1>Тыл Правый: LPF Вкл/Выкл
slider20:0<0,1,1>Тыл Центр: LPF Вкл/Выкл
slider21:1<0,1,1>Сабвуфер: LPF Вкл/Выкл
slider64:0<0,1,1>Центр Левый: LPF Вкл/Выкл
slider65:0<0,1,1>Центр Правый: LPF Вкл/Выкл

// ГРУППА 4: ЧАСТОТЫ ФИЛЬТРОВ
slider22:120<20,400,1>Фронт Левый: Частота (Гц)
slider23:120<20,400,1>Фронт Правый: Частота (Гц)
slider24:120<20,400,1>Центр: Частота (Гц)
slider25:120<20,400,1>Тыл Левый: Частота (Гц)
slider26:120<20,400,1>Тыл Правый: Частота (Гц)
slider27:120<20,400,1>Тыл Центр: Частота (Гц)
slider28:80<20,400,1>Сабвуфер: Частота (Гц)
slider66:120<20,400,1>Центр Левый: Частота (Гц)
slider67:120<20,400,1>Центр Правый: Частота (Гц)

// ГРУППА 5: ФАЗЫ
slider29:-40<-90,90,1>Фронт Левый: Фаза (°)
slider30:40<-90,90,1>Фронт Правый: Фаза (°)
slider31:0<-90,90,1>Центр: Фаза (°)
slider32:-80<-90,90,1>Тыл Левый: Фаза (°)
slider33:80<-90,90,1>Тыл Правый: Фаза (°)
slider34:0<-90,90,1>Тыл Центр: Фаза (°)
slider35:0<-90,90,1>Сабвуфер: Фаза (°)
slider68:-60<-90,90,1>Центр Левый: Фаза (°)
slider69:60<-90,90,1>Центр Правый: Фаза (°)

// ГРУППА 6: ЗАДЕРЖКИ
slider36:2<0,100,1>Фронт Левый: Задержка (мс)
slider37:2<0,100,1>Фронт Правый: Задержка (мс)
slider38:1<0,100,1>Центр: Задержка (мс)
slider39:3<0,100,1>Тыл Левый: Задержка (мс)
slider40:3<0,100,1>Тыл Правый: Задержка (мс)
slider41:2<0,100,1>Тыл Центр: Задержка (мс)
slider42:0<0,100,1>Сабвуфер: Задержка (мс)
slider70:2<0,100,1>Центр Левый: Задержка (мс)
slider71:2<0,100,1>Центр Правый: Задержка (мс)

// ГРУППА 7: ГЛОБАЛЬНЫЕ НАСТРОЙКИ
slider43:1.4<1,5,0.1>Компрессия (1=выкл)
slider44:0<-100,100,1>Баланс (%)
slider45:0<-100,100,1>Фейдер (%)
slider46:7<0,20,0.1>Мягкость (0=выкл, 20=макс)
slider47:65<0,100,1>Пространственность (%)

// ГРУППА 8: РАЗМЕРЫ БУФЕРОВ
slider48:50<10,200,1>Фронт Левый: Размер буфера (мс)
slider49:50<10,200,1>Фронт Правый: Размер буфера (мс)
slider50:50<10,200,1>Центр: Размер буфера (мс)
slider51:50<10,200,1>Тыл Левый: Размер буфера (мс)
slider52:50<10,200,1>Тыл Правый: Размер буфера (мс)
slider53:50<10,200,1>Тыл Центр: Размер буфера (мс)
slider54:50<10,200,1>Сабвуфер: Размер буфера (мс)
slider72:50<10,200,1>Центр Левый: Размер буфера (мс)
slider73:50<10,200,1>Центр Правый: Размер буфера (мс)

// ГРУППА 9: РЕЖИМЫ РАБОТЫ
slider55:0<0,1,1>Компенсация для мобильных динамиков
slider56:2<0,2,1>0=Наушники, 1=Стерео, 2=Авто
slider57:75<0,100,1>Сила HRTF эффекта (%)
slider58:1<0,1,1>Фазы вкл/выкл
slider59:0<0,1,1>Режим фаз (0=HRTF, 1=Ручной)
slider74:1<0,1,1>Матричная обработка вкл/выкл

@init
// Инициализация переменных для фазы
phase_mode_prev = 0;
phase_enabled_prev = 0;
bypass_enabled = 0;
stereo_width = 1.0;

// Переменные для адаптивного сглаживания и SBC оптимизации
prev_outL = prev_outR = 0;
smooth_coef = 0.94;
signal_level_prev = 0;
dynamics_tracking = 0;

// Адаптивные переменные
hrtf_base = 0.3;
phase_correction_factor = 1.0;
spatial_enhancement_factor = 1.0;
matrix_enabled = 1;

// Инициализация слайдеров с оптимизированными значениями для авто
slider1=0.00; slider2=0.00; slider3=0.00; slider4=0.00; slider5=0.00; slider6=0.00; slider7=0.00;
slider8=1.2; slider9=1.2; slider10=1.0; slider11=1.2; slider12=1.2; slider13=1.0; slider14=2.03;
slider15=0; slider16=0; slider17=0; slider18=0; slider19=0; slider20=0; slider21=1;
slider22=120; slider23=120; slider24=120; slider25=120; slider26=120; slider27=120; slider28=80;
slider29=-40; slider30=40; slider31=0; slider32=-80; slider33=80; slider34=0; slider35=0;
slider36=2; slider37=2; slider38=1; slider39=3; slider40=3; slider41=2; slider42=0;
slider43=1.81; slider44=0; slider45=0; slider46=2.50; slider47=100;
slider48=200; slider49=200; slider50=200; slider51=200; slider52=200; slider53=200; slider54=200;
slider55=0; slider56=2; slider57=100; slider58=0; slider59=0; slider74=0;
slider60=0.00; slider61=0.00; slider62=1.0; slider63=1.0; slider64=0; slider65=0;
slider66=120; slider67=120; slider68=-60; slider69=60; slider70=2; slider71=2;
slider72=200; slider73=200;

// Функция адаптивной настройки HRTF
function update_hrtf_base(inL, inR) (
    signal_level = abs(inL + inR) * 0.5;
    signal_level_prev = signal_level_prev * 0.95 + signal_level * 0.05;
    hrtf_base = max(0.3, min(0.4, signal_level_prev + 0.2));
);

// Улучшенная функция инициализации буфера
function init_buffer(ms) local(size) (
    size = ceil(srate * ms / 1000);
    max(size, 64);
);

// Инициализация буферов для каждого канала
bufsize_fl = init_buffer(slider48);
bufsize_fr = init_buffer(slider49);
bufsize_c  = init_buffer(slider50);
bufsize_rl = init_buffer(slider51);
bufsize_rr = init_buffer(slider52);
bufsize_rc = init_buffer(slider53);
bufsize_sw = init_buffer(slider54);
bufsize_cl = init_buffer(slider72);
bufsize_cr = init_buffer(slider73);

buffer_fl = 0;
buffer_fr = bufsize_fl;
buffer_c  = buffer_fr + bufsize_fr;
buffer_rl = buffer_c + bufsize_c;
buffer_rr = buffer_rl + bufsize_rl;
buffer_rc = buffer_rr + bufsize_rr;
buffer_sw = buffer_rc + bufsize_rc;
buffer_cl = buffer_sw + bufsize_sw;
buffer_cr = buffer_cl + bufsize_cl;
buffer_temp = buffer_cr + bufsize_cr;

// Инициализация позиций буферов
write_pos_fl = write_pos_fr = write_pos_c = write_pos_rl = write_pos_rr = write_pos_rc = write_pos_sw = write_pos_cl = write_pos_cr = 0;

// Инициализация фильтров с оптимизацией для SBC
lp_prev_fl.x1=lp_prev_fl.x2=lp_prev_fl.y1=lp_prev_fl.y2=0;
lp_prev_fr.x1=lp_prev_fr.x2=lp_prev_fr.y1=lp_prev_fr.y2=0;
lp_prev_c.x1=lp_prev_c.x2=lp_prev_c.y1=lp_prev_c.y2=0;
lp_prev_rl.x1=lp_prev_rl.x2=lp_prev_rl.y1=lp_prev_rl.y2=0;
lp_prev_rr.x1=lp_prev_rr.x2=lp_prev_rr.y1=lp_prev_rr.y2=0;
lp_prev_rc.x1=lp_prev_rc.x2=lp_prev_rc.y1=lp_prev_rc.y2=0;
lp_prev_sw.x1=lp_prev_sw.x2=lp_prev_sw.y1=lp_prev_sw.y2=0;
lp_prev_cl.x1=lp_prev_cl.x2=lp_prev_cl.y1=lp_prev_cl.y2=0;
lp_prev_cr.x1=lp_prev_cr.x2=lp_prev_cr.y1=lp_prev_cr.y2=0;

// Базовые функции с улучшенной оптимизацией для SBC
function db2gain(db) (
    pow(10, db/20);
);

function improved_lpf(input, freq, prev) local(omega, sn, cs, alpha, a0, a1, a2, b0, b1, b2, y) (
    freq = min(max(freq, 20), srate/2);
    omega = 2.0 * $pi * freq/srate;
    sn = sin(omega);
    cs = cos(omega);
    alpha = sn / (2.0 * 0.707);
    
    a0 = 1.0 + alpha;
    a1 = -2.0 * cs;
    a2 = 1.0 - alpha;
    b0 = (1.0 - cs) / 2.0;
    b1 = 1.0 - cs;
    b2 = (1.0 - cs) / 2.0;
    
    y = (b0/a0) * input + (b1/a0) * prev.x1 + (b2/a0) * prev.x2 - (a1/a0) * prev.y1 - (a2/a0) * prev.y2;
    
    prev.x2 = prev.x1;
    prev.x1 = input;
    prev.y2 = prev.y1;
    prev.y1 = y;
    
    y;
);

function delay_signal_enhanced(input, delay_ms, buffer_offset, bufsize, pos) local(delay_samples, read_pos) (
    delay_samples = min(floor(delay_ms * srate / 1000), bufsize-1);
    read_pos = (pos - delay_samples + bufsize) % bufsize;
    mem[buffer_offset + pos] = input;
    mem[buffer_offset + read_pos];
);

// Улучшенная функция фазового сдвига с учетом типа канала
function phase_shift_enhanced(input, phase_deg, is_virtual, channel_type) local(phase_factor, output, actual_phase, channel_mod) (
    slider58 == 0 ? input : (
        slider74 ? (
            slider59 == 0 ? (
                phase_factor = slider56 == 0 ? 0.7 :
                              slider56 == 1 ? 0.8 : 
                              0.9;
                
                channel_mod = channel_type == 0 ? 1.0 :  // фронт
                            channel_type == 1 ? 0.8 :  // тыл
                            0.9;                       // центр
                
                actual_phase = is_virtual ? (
                    phase_deg < 0 ? phase_deg * phase_factor * channel_mod :
                    phase_deg > 0 ? phase_deg * phase_factor * channel_mod :
                    0
                ) : phase_deg * channel_mod;
                
                output = input * cos(actual_phase * $pi/180)
            ) : (
                output = input * cos(phase_deg * $pi/180)
            )
        ) : input;
        output
    )
);

// Улучшенная пространственная обработка
function spatial_enhance_advanced(input, amount, is_rear, is_center) local(spatial, output, early_refl) (
    spatial = slider47/100;
    amount = amount * spatial * 0.3;
    output = input;
    
    slider74 ? (
        is_rear ? (
            output *= (1 + amount * 0.15);
            early_refl = delay_signal_enhanced(output, 8 + amount * 4, buffer_temp, bufsize_sw, write_pos_sw) * 0.12;
            output += early_refl;
            amount > 0 ? output += sin(output * $pi * 0.2) * amount * 0.08;
        ) : is_center ? (
            output *= (1 - amount * 0.03);
        ) : (
            output *= (1 + amount * 0.08);
            output += sin(output * $pi * 0.4) * amount * 0.04;
        );
    );
    
    abs(output) > 0.92 ? sign(output) * 0.92 : output
);

// Улучшенная функция баса с учетом типа канала
function bass_boost_enhanced(input, amount, channel_type) local(freq_dependent_boost, input_level) (
    slider74 ? (
        input_level = abs(input);
        freq_dependent_boost = amount * (
            channel_type == 0 ? 1.2 - input_level * 0.2 :  // фронт
            channel_type == 1 ? 1.0 - input_level * 0.15 : // тыл
            0.8 - input_level * 0.1                        // центр
        );
        input * (1 + freq_dependent_boost * (1 - input_level))
    ) : input * (1 + amount * 0.2)
);

// Система автокалибровки задержек
function calculate_delay_calibration() local(position_calibration, balance_factor) (
    position_calibration = 1.0 + (slider45 * 0.01) * sqrt(abs(slider44 * 0.01));
    balance_factor = 1.0 + abs(slider44) * 0.005;
    position_calibration * balance_factor;
);

// Улучшенное адаптивное сглаживание
function calculate_smooth_coef(outL, outR, prev_outL, prev_outR) local(delta) (
    delta = (abs(outL - prev_outL) + abs(outR - prev_outR)) * 0.5;
    max(0.90, min(0.98, 0.94 + delta * 0.2));
);

// Улучшенная функция мягкого клиппинга
function soft_clip_enhanced(x) local(abs_x) (
    abs_x = abs(x);
    abs_x > 0.65 ? (
        sign(x) * (0.65 + (abs_x - 0.65) * (0.35 + (1 - abs_x) * 0.1))
    ) : x
);

// Динамическая обработка сигнала
function dynamic_processor(input, threshold, ratio) local(level, gain) (
    level = abs(input);
    level > threshold ? (
        gain = 1 + (threshold - level) * (ratio - 1);
        input * gain
    ) : input
);

@sample
// Получение входного сигнала с оптимизированной нормализацией
inL = spl0 * 0.65;
inR = spl1 * 0.65;

// Обновление адаптивных параметров
update_hrtf_base(inL, inR);

// Получение параметров калибровки
delay_calibration = calculate_delay_calibration();

// Проверка включения матричной обработки
matrix_enabled = slider74;

// Если матрица выключена, применяем улучшенную стерео обработку
!matrix_enabled ? (
    outL = inL * db2gain(slider1);
    outR = inR * db2gain(slider2);
    
    // Применяем улучшенные эффекты
    outL = bass_boost_enhanced(outL, slider8 * 0.5, 0);
    outR = bass_boost_enhanced(outR, slider9 * 0.5, 0);
    
    // Улучшенный расчет баланса
    bal_left = cos((100 + slider44) * $pi/400) * (1 + abs(slider44) * 0.002);
    bal_right = cos((100 - slider44) * $pi/400) * (1 + abs(slider44) * 0.002);
    outL *= bal_left;
    outR *= bal_right;
) : (
    // Иначе выполняем полную матричную обработку с улучшениями
    
    // Настройка HRTF с адаптивной защитой
    hrtf_strength = max(slider57/100, 0.1);
    output_mode = slider56;
    hrtf_multiplier = output_mode == 0 ? 1.0 : 
                     output_mode == 1 ? 0.7 : 0.85;
    hrtf_multiplier = hrtf_base + (hrtf_multiplier - hrtf_base) * hrtf_strength;

    // Улучшенный расчет баланса
    bal_left = cos((100 + slider44) * $pi/400) * (1 + abs(slider44) * 0.002);
    bal_right = cos((100 - slider44) * $pi/400) * (1 + abs(slider44) * 0.002);

    // Улучшенный расчет фейдера с плавной интерполяцией
    fade_value = slider45/100;
    fade_exp = exp(abs(fade_value) * 2.5);
    fade_smooth = fade_value * (1 - abs(fade_value) * 0.1);

    // Улучшенный расчет затухания
    fade_front = fade_value >= 0 ? 1.0 : 1 / (fade_exp * 1.5);
    fade_rear = fade_value <= 0 ? 1.0 : 1 / (fade_exp * 1.5);

    // Улучшенные коэффициенты позиционирования
    position_front = fade_value >= 0 ? 1 + fade_smooth * 0.8 : 1 / (1 - fade_smooth * 0.4);
    position_rear = fade_value <= 0 ? 1 - fade_smooth * 0.8 : 1 / (1 + fade_smooth * 0.4);

    // Улучшенный расчет затухания сабвуфера
    sub_fade = fade_value >= 0 ? 
        1 / (1 + fade_value * 2.2 * (1 - abs(fade_value) * 0.3)) :
        1.0;

    // Улучшенная HRTF матрица
    hrtf_fl_l = 0.7 * bal_left * pow(fade_front, 1.2) * position_front * hrtf_multiplier * (1 + space * 0.05);   
    hrtf_fl_r = 0.15 * bal_right * pow(fade_front, 1.2) * position_front * hrtf_multiplier;   
    hrtf_fr_l = 0.15 * bal_left * pow(fade_front, 1.2) * position_front * hrtf_multiplier;    
    hrtf_fr_r = 0.7 * bal_right * pow(fade_front, 1.2) * position_front * hrtf_multiplier * (1 + space * 0.05);   

    // Центральные каналы с улучшенной фокусировкой
    hrtf_c_l = 0.45 * bal_left * (pow(fade_front, 1.1) * 0.7 + pow(fade_rear, 1.1) * 0.3) * min(position_front, position_rear) * hrtf_multiplier;     
    hrtf_c_r = 0.45 * bal_right * (pow(fade_front, 1.1) * 0.7 + pow(fade_rear, 1.1) * 0.3) * min(position_front, position_rear) * hrtf_multiplier;    

    // Боковые центральные каналы с улучшенной шириной
    hrtf_cl_l = 0.55 * bal_left * (pow(fade_front, 1.1) * 0.8 + pow(fade_rear, 1.1) * 0.2) * min(position_front, position_rear) * hrtf_multiplier * (1 + space * 0.03);
    hrtf_cl_r = 0.15 * bal_right * (pow(fade_front, 1.1) * 0.8 + pow(fade_rear, 1.1) * 0.2) * min(position_front, position_rear) * hrtf_multiplier;
    hrtf_cr_l = 0.15 * bal_left * (pow(fade_front, 1.1) * 0.8 + pow(fade_rear, 1.1) * 0.2) * min(position_front, position_rear) * hrtf_multiplier;
    hrtf_cr_r = 0.55 * bal_right * (pow(fade_front, 1.1) * 0.8 + pow(fade_rear, 1.1) * 0.2) * min(position_front, position_rear) * hrtf_multiplier * (1 + space * 0.03);

    // Тыловые каналы с улучшенной глубиной
    hrtf_rl_l = 0.65 * bal_left * pow(fade_rear, 1.2) * position_rear * hrtf_multiplier * (1 + space * 0.06);   
    hrtf_rl_r = 0.1 * bal_right * pow(fade_rear, 1.2) * position_rear * hrtf_multiplier;   
    hrtf_rr_l = 0.1 * bal_left * pow(fade_rear, 1.2) * position_rear * hrtf_multiplier;    
    hrtf_rr_r = 0.65 * bal_right * pow(fade_rear, 1.2) * position_rear * hrtf_multiplier * (1 + space * 0.06);   
    hrtf_rc_l = 0.35 * bal_left * pow(fade_rear, 1.2) * position_rear * hrtf_multiplier;   
    hrtf_rc_r = 0.35 * bal_right * pow(fade_rear, 1.2) * position_rear * hrtf_multiplier;   

    // Сабвуфер с улучшенной интеграцией
    hrtf_sw_l = 0.45 * bal_left * sub_fade * hrtf_multiplier * (1 - space * 0.1);   
    hrtf_sw_r = 0.45 * bal_right * sub_fade * hrtf_multiplier * (1 - space * 0.1);

    // Улучшенная обработка каналов
    // Фронт левый
    fl = inL;
    fl *= db2gain(slider1);
    fl = slider15 ? improved_lpf(fl, slider22, lp_prev_fl) : fl;
    fl = phase_shift_enhanced(fl, slider29, 1, 0);
    fl = delay_signal_enhanced(fl, slider36 * delay_calibration * position_front, buffer_fl, bufsize_fl, write_pos_fl);
    write_pos_fl = (write_pos_fl + 1) % bufsize_fl;
    fl = bass_boost_enhanced(fl, slider8, 0);
    fl = spatial_enhance_advanced(fl, 1.0, 0, 0);
    fl = soft_clip_enhanced(fl);

    // Фронт правый
    fr = inR;
    fr *= db2gain(slider2);
    fr = slider16 ? improved_lpf(fr, slider23, lp_prev_fr) : fr;
    fr = phase_shift_enhanced(fr, slider30, 1, 0);
    fr = delay_signal_enhanced(fr, slider37 * delay_calibration * position_front, buffer_fr, bufsize_fr, write_pos_fr);
    write_pos_fr = (write_pos_fr + 1) % bufsize_fr;
    fr = bass_boost_enhanced(fr, slider9, 0);
    fr = spatial_enhance_advanced(fr, 1.0, 0, 0);
    fr = soft_clip_enhanced(fr);

    // Центр
    c = (inL + inR) * 0.5;
    c *= db2gain(slider3);
    c = slider17 ? improved_lpf(c, slider24, lp_prev_c) : c;
    c = phase_shift_enhanced(c, slider31, 1, 2);
    c = delay_signal_enhanced(c, slider38 * delay_calibration * min(position_front, position_rear), buffer_c, bufsize_c, write_pos_c);
    write_pos_c = (write_pos_c + 1) % bufsize_c;
    c = bass_boost_enhanced(c, slider10, 2);
    c = spatial_enhance_advanced(c, 0.5, 0, 1);
    c = soft_clip_enhanced(c);

    // Центр левый
    cl = inL;
    cl *= db2gain(slider60);
    cl = slider64 ? improved_lpf(cl, slider66, lp_prev_cl) : cl;
    cl = phase_shift_enhanced(cl, slider68, 1, 2);
    cl = delay_signal_enhanced(cl, slider70 * delay_calibration * min(position_front, position_rear), buffer_cl, bufsize_cl, write_pos_cl);
    write_pos_cl = (write_pos_cl + 1) % bufsize_cl;
    cl = bass_boost_enhanced(cl, slider62, 2);
    cl = spatial_enhance_advanced(cl, 0.6, 0, 1);
    cl = soft_clip_enhanced(cl);

    // Центр правый
    cr = inR;
    cr *= db2gain(slider61);
    cr = slider65 ? improved_lpf(cr, slider67, lp_prev_cr) : cr;
    cr = phase_shift_enhanced(cr, slider69, 1, 2);
    cr = delay_signal_enhanced(cr, slider71 * delay_calibration * min(position_front, position_rear), buffer_cr, bufsize_cr, write_pos_cr);
    write_pos_cr = (write_pos_cr + 1) % bufsize_cr;
    cr = bass_boost_enhanced(cr, slider63, 2);
    cr = spatial_enhance_advanced(cr, 0.6, 0, 1);
    cr = soft_clip_enhanced(cr);

    // Тыл левый
    rl = inL;
    rl *= db2gain(slider4);
    rl = slider18 ? improved_lpf(rl, slider25, lp_prev_rl) : rl;
    rl = phase_shift_enhanced(rl, slider32, 1, 1);
    rl = delay_signal_enhanced(rl, (slider39 + 10) * delay_calibration * position_rear, buffer_rl, bufsize_rl, write_pos_rl);
    write_pos_rl = (write_pos_rl + 1) % bufsize_rl;
    rl = bass_boost_enhanced(rl, slider11, 1);
    rl = spatial_enhance_advanced(rl, 1.0, 1, 0);
    rl = soft_clip_enhanced(rl);

    // Тыл правый
    rr = inR;
    rr *= db2gain(slider5);
    rr = slider19 ? improved_lpf(rr, slider26, lp_prev_rr) : rr;
    rr = phase_shift_enhanced(rr, slider33, 1, 1);
    rr = delay_signal_enhanced(rr, (slider40 + 10) * delay_calibration * position_rear, buffer_rr, bufsize_rr, write_pos_rr);
    write_pos_rr = (write_pos_rr + 1) % bufsize_rr;
    rr = bass_boost_enhanced(rr, slider12, 1);
    rr = spatial_enhance_advanced(rr, 1.0, 1, 0);
    rr = soft_clip_enhanced(rr);

    // Тыл центр
    rc = (inL + inR) * 0.5;
    rc *= db2gain(slider6);
    rc = slider20 ? improved_lpf(rc, slider27, lp_prev_rc) : rc;
    rc = phase_shift_enhanced(rc, slider34, 1, 1);
    rc = delay_signal_enhanced(rc, (slider41 + 15) * delay_calibration * position_rear, buffer_rc, bufsize_rc, write_pos_rc);
    write_pos_rc = (write_pos_rc + 1) % bufsize_rc;
    rc = bass_boost_enhanced(rc, slider13, 1);
    rc = spatial_enhance_advanced(rc, 0.7, 1, 1);
    rc = soft_clip_enhanced(rc);

    // Сабвуфер с улучшенной обработкой
    sw = (inL + inR) * 0.5;
    sw *= db2gain(slider7);
    sw = slider21 ? improved_lpf(sw, slider28, lp_prev_sw) : sw;
    sw = phase_shift_enhanced(sw, slider35, 0, 2);
    sw = delay_signal_enhanced(sw, slider42 * delay_calibration * (1 + (1-sub_fade) * 0.5), buffer_sw, bufsize_sw, write_pos_sw);
    write_pos_sw = (write_pos_sw + 1) % bufsize_sw;
    sw = bass_boost_enhanced(sw, slider14, 2);
    sw = soft_clip_enhanced(sw);

    // Расчет пространственной матрицы с улучшенной адаптивностью
    space = slider47/100;
    space_matrix_l = 1 + space * (0.15 + 0.05 * (1 - abs(bal_left)));
    space_matrix_r = 1 + space * (0.15 + 0.05 * (1 - abs(bal_right)));

    // HRTF матричное микширование с оптимизированными коэффициентами
    outL = (
        fl * hrtf_fl_l * space_matrix_l +
        fr * hrtf_fr_l +
        c  * hrtf_c_l +
        cl * hrtf_cl_l +
        cr * hrtf_cr_l +
        rl * hrtf_rl_l * space_matrix_l +
        rr * hrtf_rr_l +
        rc * hrtf_rc_l +
        sw * hrtf_sw_l
    ) * 0.28;

    outR = (
        fl * hrtf_fl_r +
        fr * hrtf_fr_r * space_matrix_r +
        c  * hrtf_c_r +
        cl * hrtf_cl_r +
        cr * hrtf_cr_r +
        rl * hrtf_rl_r +
        rr * hrtf_rr_r * space_matrix_r +
        rc * hrtf_rc_r +
        sw * hrtf_sw_r
    ) * 0.28;
);

// Общая постобработка для обоих режимов
// Применение улучшенной мягкости
soft = slider46/20;
outL = outL * (1-soft) + tanh(outL * (0.8 + soft * 0.1)) * soft;
outR = outR * (1-soft) + tanh(outR * (0.8 + soft * 0.1)) * soft;

// Применение улучшенной компрессии с динамической адаптацией
ratio = slider43;
ratio > 1 ? (
    dynamics_tracking = dynamics_tracking * 0.95 + (abs(outL) + abs(outR)) * 0.025;
    comp_threshold = 0.5 + dynamics_tracking * 0.2;
    outL = dynamic_processor(outL, comp_threshold, ratio);
    outR = dynamic_processor(outR, comp_threshold, ratio);
);

// Улучшенная компенсация для мобильных устройств
mobile_comp = slider55;
mobile_comp * (
    outL = outL * (1 + 0.12 * (1 - abs(outL))) + outL * 0.04;
    outR = outR * (1 + 0.12 * (1 - abs(outR))) + outR * 0.04;
    outL = outL - outL * 0.08 * (abs(outL) > 0.8);
    outR = outR - outR * 0.08 * (abs(outR) > 0.8);
    outL = outL * 0.92 + outL * 0.08 * sign(outL);
    outR = outR * 0.92 + outR * 0.08 * sign(outR);
);

// Применение адаптивного сглаживания
smooth_coef = calculate_smooth_coef(outL, outR, prev_outL, prev_outR);
outL = outL * smooth_coef + prev_outL * (1 - smooth_coef);
outR = outR * smooth_coef + prev_outR * (1 - smooth_coef);
prev_outL = outL;
prev_outR = outR;

// Финальное ограничение с улучшенным мягким клиппингом
outL = soft_clip_enhanced(min(max(outL, -0.85), 0.85));
outR = soft_clip_enhanced(min(max(outR, -0.85), 0.85));

// Финальное усиление и выход
spl0 = outL * 1.1;
spl1 = outR * 1.1;